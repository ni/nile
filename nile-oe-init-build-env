#!/usr/bin/env

SCRIPT_ROOT=$(realpath $(dirname ${BASH_SOURCE:-${0}}))


usage() {
	cat >&2 <<EOF
$(basename ${BASH_SOURCE}) [-h] \
	[-s SSTATE_MIRROR_PREFIX SSTATE_MIRROR_PATH] \
	[[--] OE_INIT_ARGS...]

Arguments:
-h, --help	Print this usage text and exit.
-t, --template	Template to use for this build environment (defaults to a generic ARM64 machine configuration).
-s, --sstate-mirror SSTATE_MIRROR_PREFIX SSTATE_MIRROR_PATH
	Add the SSTATE_MIRROR_PREFIX/_PATH pair to the bitbake environment's
	SSTATE_MIRRORS variable.

EOF
}
sstate_mirrors=()
positionals=()
template="default"

set -u
while [ $# -ge 1 ]; do case "$1" in
	-d|--download-dir)
		shift
		export DL_DIR=$(realpath "$1")
		shift
		;;
	-h|--help)
		usage
		return 0
		;;
	-t|--template)
		if [ -z "${2:-}" ]; then
			echo "Warning: --template argument expected a string"
			shift 1
 		else
			template=$2
			shift 2
		fi
		;;
	-s|--sstate-mirror)
		if [ -z "${2:-}" -o -z "${3:-}" ]; then
			echo "ERROR: --sstate-mirror argument expected two strings." >&2
			return 2
		fi
		sstate_mirrors+=("$2 $3")
		shift 3
		;;
	--)
		shift
		for positional in $@; do
			positionals+=($positional)
		done
		break
		;;
	-*|--*)
		echo "ERROR: Unknown script argument $1." >&2
		return 2
		;;
	*)
		positionals+=($1)
		shift
		;;
esac; done
set +u

# Determine the OE build workspace path. We honor the user's BUILDDIR env
# variable, unless it is undefined, or overwritten with positional arguments.
if [ -n "${positionals[0]}" ]; then
	BUILDDIR=${positionals[0]}
	positionals=${positionals[@]:1}  # shift array
elif [ -z "$BUILDDIR" ]; then
	# if the user has expressed no preference, default to :build/
	BUILDDIR="${SCRIPT_ROOT}/build"
fi  # implicit-else: use the users's BUILDDIR value
echo "INFO: Using ${BUILDDIR} as the OE build workspace."


REPO_ROOT="${SCRIPT_ROOT}"

# LOCAL_LAYERSDIR is used by the meta-nile bblayers.conf to locate the BB layer
# top-level directory for layers contained directly within the meta-nile repo.
# For now this is the same as REPO_ROOT since we only have one layer
export LOCAL_LAYERSDIR="${REPO_ROOT}"

# GIT_REPODIR is used by the meta-talladega bblayers.conf to locate the BB layer
# top-level directory for repos sourced from git submodules.
export GIT_REPODIR="${REPO_ROOT}/sources"


# Enable color terminal by default
export TERM=${TERM:-xterm-256color}

BITBAKEDIR=${REPO_ROOT}/sources/bitbake
OEROOT=${REPO_ROOT}/sources/openembedded-core

## BITBAKE VARIABLES ##
# Users can assert the maximum number of concurrent bitbake threads via the
# BB_NUMBER_THREADS variable, or let this script calculate a reasonable value
# based on the number of cores.
if [ -z "${BB_NUMBER_THREADS:-}" ]; then
	echo "INFO: BB_NUMBER_THREADS not set. Calculating..."
	# num_cores * 2 is the recommended value from the yocto manual
	BB_NUMBER_THREADS=$(($(nproc) * 2))
fi
export BB_NUMBER_THREADS
echo "BB_NUMBER_THREADS=${BB_NUMBER_THREADS}"

# define the location of bitbake configuration files, which will be copied
# into the build workspace, if one needs to be created.
export TEMPLATECONF="${SCRIPT_ROOT}/meta-nile/conf/templates/${template}"
echo "TEMPLATECONF=${TEMPLATECONF}"

export SSTATE_MIRRORS="${SSTATE_MIRRORS:-} ${sstate_mirrors[@]/%/ \\n}"

# Define here all Nile-specific variables which need to be passed to bitbake
# (should include everything we've set above which is non-standard)
# Any PAT tokens should be captured here as well.
export BB_ENV_PASSTHROUGH_ADDITIONS="${BB_ENV_PASSTHROUGH_ADDITIONS:-} \
	BB_NUMBER_THREADS \
	DL_DIR \
	GIT_REPODIR \
	GITHUB_TOKEN \
	LOCAL_LAYERSDIR \
	BB_SIGNATURE_HANDLER \
	BB_HASHSERVE \
	SSTATE_DIR \
	SSTATE_MIRRORS \
"

## PYREX VARIABLES ###
# Setup pyrex config variables
export PYREXCONFFILE=${PYREXCONFFILE:-"${SCRIPT_ROOT}/pyrex.ini"}
export PYREX_CONFIG_BIND="${REPO_ROOT}"
export PYREX_OEINIT="${REPO_ROOT}/scripts/pyrex-oe-init"
export PYREX_ROOT="${REPO_ROOT}/sources/pyrex"

export PYREX_BUILD_NILE_IMAGE="${PYREX_BUILD_NILE_IMAGE:-build-nile}"
echo "INFO: Using pyrex image: ${PYREX_BUILD_NILE_IMAGE}"

unset SCRIPT_ROOT

if [ -z "${PYREX_TEMP_ENV_FILE:-}" ]; then
	PYREX_TEMP_ENV_FILE=$(mktemp -t pyrex-env.XXXXXX)
fi

pyrex_cleanup() {
	rm -f "$PYREX_TEMP_ENV_FILE"
	unset PYREX_OEINIT PYREX_ROOT PYREX_TEMP_ENV_FILE pyrex_cleanup
}

# Write out a netrc file with GH/AzDO tokens, if provided, so that they
# can be picked up by invocations of git within the container.
${REPO_ROOT}/scripts/init-netrc "${BUILDDIR}/.netrc"

# Invoke pyrex to: standup our build container and BB build directory, and to
# "capture" the current shell within the pyrex toolchain context.
"$PYREX_ROOT/pyrex.py" capture \
		-a PYREX_OEINIT "$PYREX_OEINIT" \
		-e PYREXCONFFILE \
		-e TEMPLATECONF \
		-- 9 "${BUILDDIR}" "${positionals[@]}" \
		9> "$PYREX_TEMP_ENV_FILE"
if [ $? -ne 0 ]; then
	pyrex_cleanup
	return 1
fi

. "$PYREX_TEMP_ENV_FILE"
if [ $? -ne 0 ]; then
	pyrex_cleanup
	return 1
fi

pyrex_cleanup
